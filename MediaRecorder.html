 <!DOCTYPE html>
<html>
	
 <head>
    <title>MediaStream Recording</title>
    <meta http-equiv='Content-Type' content='text/html; charset=utf-8'/>
    <script type="text/javascript" src='https://www.w3.org/Tools/respec/respec-w3c-common' class='remove' async></script>
    <script type="text/javascript" class='remove'>
            var respecConfig = {
                  specStatus: "ED",
                  editors: [{
                  	name: "Jim Barnett",
                  	company: "Genesys",
                  companyURL: "http://www.genesyslab.com"},
                     { name: "Travis Leithead", 
                            company: "Microsoft Corp.",
                            url: "mailto:travis.leithead@microsoft.com?subject=MediaStream Capture Scenarios Feedback",
                            companyURL: "http://www.microsoft.com"}],
                  publishDate:  "2013-01-18",
                  edDraftURI:   "http://dvcs.w3.org/hg/dap/raw-file/tip/media-stream-capture/RecordingProposal.html",
                  previousPublishDate: null,
                  prevED: "",
                  noIDLIn:  true,
                  inlineCSS:  true,
                  noRecTrack:  true,
                  shortName:  "recording",
                  extraCSS: ["http://dev.w3.org/2009/dap/ReSpec.js/css/respec.css"],
                  wg:         ["Media Capture Task Force"],
                  wgURI:    ["http://www.w3.org/wiki/Media_Capture"],
                  wgPublicList: "public-media-capture",
                  wgPatentURI:  ["http://www.w3.org/2004/01/pp-impl/43696/status", "http://www.w3.org/2004/01/pp-impl/47318/status"]
              };
    </script>
    <style type="text/css">
      /* ReSpec.js CSS optimizations (Richard Tibbett) - cut-n-paste :) */
      div.example {
          border-top: 1px solid #ff4500;
          border-bottom: 1px solid #ff4500;
          background: #fff;
          padding:    1em;
          font-size: 0.9em;
          margin-top: 1em;
      }
      div.example::before {
          content:    "Example";
          display:    block;
          width:      150px;
          background: #ff4500;
          color:  #fff;
          font-family:    initial;
          padding:    3px;
          padding-left: 5px;
          font-weight:    bold;
          margin: -1em 0 1em -1em;
      }

      /* Clean up pre.idl */
      pre.idl::before {
          font-size:0.9em;
      }

      /* Add better spacing to sections */
      section, .section {
          margin-bottom: 2em;
      }

      /* Reduce note & issue render size */
      .note, .issue {
          font-size:0.8em;
      }

      /* Add addition spacing to <ol> and <ul> for rule definition */
      ol.rule li, ul.rule li {
          padding:0.2em;
      }
    </style>
  </head>

  
  <body>
  	<section id="abstract">
  		<p>This document defines a recording API for use with MediaStreams as defined in Media Capture and Streams
  			[[!GETUSERMEDIA]].</p></section>
   
  <section id="sotd">
  
    
      
        <p>
          <em>This section describes the status of this document at the time of its publication. Other
          documents may supersede this document. A list of current <acronym title="World Wide Web Consortium">W3C</acronym> publications and the latest revision
          of this technical report can be found in the <a href="http://www.w3.org/TR/"><acronym title="World Wide Web Consortium">W3C</acronym> technical reports
          index</a> at http://www.w3.org/TR/.</em>
        </p>
        
    <p>This document is not complete. It is subject to major changes and, while
    early experimentations are encouraged, it is therefore not intended for
    implementation. 
    The Media Capture Task Force expects this specification to evolve
    significantly based on:</p>

    <ul>
      <li>Privacy issues that arise when capturing media.</li>

      <li>Technical discussions within the task force.</li>

      <li>Experience gained through early experimentations.</li>

      <li>Feedback received from other groups and individuals.</li>
    </ul>
  

      
    
  
</section>
  

<section id="overview"><h2>Overview</h2>
  <p>This API attempts to make basic recording very simple, while still allowing for more complex use cases.  In the simplest case,
  	the application instatiates the MediaRecorder object, calls record() and then calls stopRecord() or waits for the MediaStream to be ended.  The contents of the recording
  	will be made available in the platform's default encoding via the dataavailable event.  Functions are available to query
  	the platform's available set of encodings, and to select the desired ones if the author wishes.  The application can also choose 
  	how much data it wants to receive at one time.  By default a Blob containing the entire recording is returned when
  	the recording finishes.  However the application can choose to receive smaller buffers of data at regular intervals.  </p>
 </section>
 



 <section id="MediaRecorderAPI"><h2>Media Recorder API</h2>

<dl title='[Constructor (MediaStream stream)] interface MediaRecorder : EventTarget' class="idl">
	<dt>readonly attribute MediaStream stream</dt><dd>The MediaStream passed in to the constructor.</dd>
	<dt>readonly attribute RecordingStateEnum state</dt><dd>The current state of the MediaRecorder object. </dd>
	<dt>readonly attribute unsigned long imageWidth</dt><dd>The width of the video or photo image to capture.  
		The initial value will be a platform-supplied default.</dd>
	<dt>readonly attribute unsigned long imageHeight</dt><dd>The height of the video or photo image to capture.  
		The initial value will be a platform-supplied default.</dd>
	<dt>readonly attribute DOMString mimeType</dt><dd>The MIME type for recording.  It specifies the 
		container format as well as the audio and video capture formats.  The initial value will
		be a platform-supplied default.</dd>
	<dt>attribute EventHandler onrecording</dt><dd>Called to handle the recording event.</dd>
	<dt>attribute EventHandler onstop</dt><dd>Called to handle the stop event.</dd>
	<dt>attribute EventHandler ondataavailable</dt><dd>Called to handle the dataavailable event.  Note that the Blob (see [[!FILE-API]]) of recorded data is contained in this event and can
          	be accessed via the 'data' attribute.</dd>
          	<dt>attribute EventHandler onpause</dt><dd>Called to handle the pause event. </dd>
          	<dt>attribute EventHandler onresume</dt><dd>Called to handle the resume event. </dd>
          	<dt>attribute EventHandler onmutetrack</dt><dd>Called to handle the mutetrack event. </dd>
          	<dt>attribute EventHandler onunmutetrack</dt><dd>Called to handle the unmutetrack event. </dd>
          	<dt>attribute EventHandler onphoto</dt><dd>Called to handle the photo event. The photo event returns a photo (as a Blob) in a compressed format (for example: PNG/JPEG) rather than a raw ImageData object due to the expected large, uncompressed size of the resulting photos.</dd>
          	<dt>attribute EventHandler onerror</dt><dd>Called to handle the recordingerror event. </dd>
          	<dt>attribute EventHandler onwarning</dt><dd>Called to handle the recordingwarning event. </dd>
          	<dt>void record ()</dt>
<dd>When a <code>MediaRecorder</code> object’s <code>record()</code> method is invoked,
			then, if the <code>state</code> is not "inactive", the UA MUST
				raise an <code>INVALID_STATE</code> exception and return immediately.  
			Otherwise, it MUST queue a task, using the DOM manipulation task source, 
			that runs the following steps:
		<ol>
				<li>Set <code>state</code> to 'recording' and wait until media
					
					becomes available from <code>stream</code>.</li>
			<li>Once data becomes available raise a <code>recording</code> event and start gathering the 
				
				data into a Blob (see [[!FILE-API]]). </li>
		<li>If the <code>timeSlice</code> argument has been provided, then once <code>timeSlice</code>
			milliseconds of data have been colleced, raise a <code>dataavailable</code> event containing
			the Blob of collected data, and start gathering a new Blob of data.  Otherwise (if <code>timeSlice</code>
			has not been provided), continue gathering data into the original Blob.</li>
			<li>When the <code>stream</code> is ended set <code>recording</code>
				to 'false' and stop gathering data.</li>
					<li>Then  raise a <code>dataavailable</code> event containing the Blob of data.</li>
					<li>Finally, raise a <code>stoprecording</code> event.</li> 
			</ol>
			
			<p>Note that <code>stop()</code>,
				<code>requestData()</code>, <code>pause</code>,
				and <code>muteTrack</code> also affect the recording behavior.</p>
				

			<p>The UA <em title="must" class="rfc2119">must</em> record the MediaStream
			in such a way that the original Tracks can be retrieved at playback time.  If any Track within the
			MediaStream is muted at any time (i.e., if its <code>readyState</code> is set to <code>muted</code>), the UA
			<em title="must" class="rfc2119">must</em> insert black frames or silence until the Track is unmuted. If the UA is 
			unable to start recording or at any point is unable to contine recording, it <em title="must" class="rfc2119">must</em> raise 
			a <code>recordingerror</code> event, follwowed by a <code>dataavailable</code> event containing
			the Blob it has gathered, follwed by the <code>stoprecording</code> event.    
		</p>
		<dl class='parameters'>
            <dt>optional  long? timeslice</dt>
            <dd>
              The number of milliseconds of data to return in a single Blob.
            </dd>
          </dl>
          </dd>
          
    <dt>void stop()</dt>
    
    <dd>When a <code>MediaRecorder</code> object’s <code>stopRecording</code> method is invoked,
          then if <code>state</code> is "inactive", the user agent MUST
          raise an INVALID_STATE exception and return immediately.  Otherwise it MUST 
          queue a task, using the DOM manipulation task source, that runs the following steps:
		<ol>	
			<li>Set <code>state</code> to 'inactive' and stop gathering data. </li>
			<li>Raise a <code>dataavailable</code> event containing the Blob of data that has been gathered.</li>
			<li>Raise a <code>recordingdone</code> event</li>		
			</ol>
			</dd>
			<dt>void pause()</dt>
			<dd>When a <code>MediaRecorder</code> object’s <code>pause()</code>method is invoked,
	then if <code>state</code> is  "inactive"
          the user agent <em title="must" class="rfc2119">must</em> raise an INVALID_STATE exception
          and return immediately.  Otherwise it <em title="must" class="rfc2119">must</em>
          queue a task, using the DOM manipulation task source, that runs the following steps:
		<ol>
		<li>Set <code>state</code> to "paused".</li>
		<li>Stop gathering data into its current Blob (but keep the Blob available so that 
			recording can be resumed in the future).</li>
			<li>Raise a <code>pause</code> event </li>
	</ol>
	</dd>
	<dt>void resume()</dt>
	<dd>When a <code>MediaRecorder</code> object’s <code>resume()</code> method is invoked,
	then if <code>state</code> is  "inactive"
          the user agent <em title="must" class="rfc2119">must</em> raise an INVALID_STATE exception
          and return immediately.  Otherwise it <em title="must" class="rfc2119">must</em>
          queue a task, using the DOM manipulation task source, that runs the following steps:
		<ol>
		<li>Set <code>state</code> to "recording".</li>
		<li>Resume (or continue) gathering data into its current Blob.</li>
		<li>Raise a <code>resume</code> event.</li>
	</ol></dd>
	
	<dt>void muteTrack()</dt>
	<dd>When a 
		<code>MediaRecorder</code> object’s <code>muteTrack()</code> method is invoked,
	then if <code>state</code> is not "recording"
          the user agent <em title="must" class="rfc2119">must</em> raise an INVALID_STATE exception
          and return immediately.  Otherwise if the <code>trackID</code> provided is not the 
          <code>id</code> of a Track object in <code>stream</code>'s <code>audioTrackList</code>
          or <code>videoTrackList</code> it <em title="must" class="rfc2119">must</em> raise an INVALID_TRACK_ID exception
          and return immediately.  Otherwise it <em title="must" class="rfc2119">must</em>
          queue a task, using the DOM manipulation task source, that runs the following steps:
		<ol>
		<li>If the specified Track is a video track, begin inserting black frames into the Blob
			in place of any data coming from the underlying source.  Otherwise (the Track is an audio track)
			insert silence into the Blob in place of any data coming from the underlying source.</li>
			<li>Raise a <code>mutetrackrecording</code> event.</li>
	</ol>
	<dl class='parameters'>
            <dt>DOMString trackID</dt>
            <dd>
              The id of the audio or video track to mute.
            </dd>
          </dl>
	</dd>
	<dt>void unmuteTrack()</dt>
	<dd>
		When a <code>MediaRecorder</code> object’s <code>unmuteTrack()</code> method is invoked,
	then if <code>state</code> is not "recording",
          the user agent <em title="must" class="rfc2119">must</em> raise an INVALID_STATE exception
          and return immediately. Otherwise if the <code>trackID</code> provided is not the 
          <code>id</code> of a Track object in <code>stream</code>'s <code>audioTrackList</code>
          or <code>videoTrackList</code> it <em title="must" class="rfc2119">must</em> raise an INVALID_TRACK_ID exception
          and return immediately. Otherwise it <em title="must" class="rfc2119">must</em>
          queue a task, using the DOM manipulation task source, that runs the following steps:
		<ol>
			<li>Until such time as data is available for this Track from the underlying media source,
				 insert black frames (for a video track) or silence (for an audio track) into the current Blob. </li>
		<li>Once data is available for this Track from the underlying media source, start collecting
			it into the current Blob. </li>
	 <li>Raise an <code>unmutetrack</code> event.</li>
	 </ol>
		<dl class='parameters'>
            <dt>DOMString trackID</dt>
            <dd>
              The id of the audio or video track to unmute.
            </dd>
          </dl>
          </dd>
   <dt>void takePhoto()</dt>
   <dd>
   	When a <code>MediaRecorder</code> object’s <code>takePhoto()</code> method is invoked,
	then  if the <code>trackID</code> provided is not the 
          <code>id</code> of a Track object in <code>stream</code>'s  <code>videoTrackList</code>
          whose <code>readyState</code> is "live", the UA MUST raise an INVALID_TRACK_ID exception
          and return immediately. Otherwise it MUST
          queue a task, using the DOM manipulation task source, that runs the following steps:
		<ol>
			<li>Gather data from the Track into a Blob containing a single still image. The method of doing
				this will depend on the underlying device.  Some devices may just do a frame grab, while others
				may temporarilly stop streaming data, reconfigure themselves with the appropriate photo settings, take the photo,
				and then resume streaming.  In this case, the stopping and restarting of streaming <em title="should" class="rfc2119">should</em>
				cause <code>mute</code> and <code>unmute</code> events to fire on the Track in question.  </li>
	 <li>Raise an <code>photo</code> event containing the Blob.</li>
	</ol>
   	<dl class='parameters'>
            <dt>DOMString trackID</dt>
            <dd>
              The id of the video track from which to take a snapshot.
            </dd>
          </dl>
   	</dd>
   	<dt>void requestData()</dt>
   	<dd>
   	When a <code>MediaRecorder</code>object’s <code>requestData()</code> method is invoked,
	then if <code>state</code> is not "recording"
          the user agent <em title="must" class="rfc2119">must</em> raise an INVALID_STATE exception
          and return immediately.  Otherwise it <em title="must" class="rfc2119">must</em>
          queue a task, using the DOM manipulation task source, that runs the following steps:
		<ol>
		<li>Raise a <code>dataavailable</code> event containing the current Blob of saved data.</li>
		<li>Create a new Blob and gather subsequent data into it.</li>
	</ol>	
   		</dd>
   		
<dt>AvailableSettings getOptions()</dt>
<dd>When a <code>MediaRecorder</code> object’s <code>getOptions()</code> method is invoked,
          the user agent <em title="must" class="rfc2119">must </em>return an 
          	AvailableSettings structure
          containing the set of recording options that it supports.  These are the legal
          values that can be set via <code>setOptions</code>.
	</dd>

<dt>void setOptions(RecordingSettings optionValues)</dt>
<dd>
	When a 
			<code>MediaRecorder</code> object’s <code>setOptions()</code> method is invoked,
				then if <code>state</code> is not
					"inactive", the user agent <em title="must" class="rfc2119">must</em> raise an INVALID_STATE
					exception and return immediately.  Otherwise it <em title="must" class="rfc2119">must</em>
					run the following steps before returning:
		<ol>
				<li>Let <em>currentOptions</em> be the current set of options that are specified
					to be used for recording by the MediaRecorder.  (If setOptions() has not yet been called, these will
					be the UA's defaults.)</li>
			<li>For each option that is specified in the <code>optionVlaues</code> argument,
				if the UA does not support it, raise a UNSUPPORTED_OPTION exception, set <em>currentOptions</em>
				back to its value in step 2, and terminate these steps.  Otherwise
				replace the corresponding member of <em>currentOptions</em> with the specified value.</li>
			</ol>
			
			
	</dd>
          	
</dl>




<p>The  <code>MediaRecorder()</code>
      constructor takes one argument which
      <em title="must" class="rfc2119">must</em> be of type <code>MediaStream</code> (see [[!GETUSERMEDIA]]). When the constructor
      is invoked, the UA <em title="must" class="rfc2119">must</em> construct a new <a class="idlType" href="#idl-def-MediaRecorder"><code>MediaRecorder</a></code> object,
      	 set its <a href="#widl-mediastream">mediaStream</a> attribute to be the provided MediaStream, set its <a href="#widl-state">state</a> attribute to 'inactive'
      	 and return the object.</p>  
      	 
	


<section id="RecordingStateEnum">
	<h3>RecordingStateEnum</h3>
	<dl title="enum RecordingStateEnum" class="idl">
   <dt>inactive</dt>
   <dd>Recording is not occuring. (Either it has not been started or it has been stopped.).</dd>
   <dt>recording</dt>
   <dd>Recording has been started and the UA is capturing data..</dd>
   <dt>paused</dt>
   <dd>Recording has been started, then paused, and not yet stopped or resumed.</dd> </dl>

	</section>  
</section> 
	
<section id="blob-event">
	<h2>Blob Event</h2>
	
	<dl title='[Constructor] interface BlobEvent : Event' class='idl'>
  <dt>readonly attribute Blob data</dt>
  <dd>
    Returns a Blob object whose type attribute indicates the encoding of the blob data. An implementation must return a Blob in a format that is capable of being viewed in an HTML <code>&lt;img&gt;</code> tag. .
  </dd>
</dl>


	<h3>BlobEventInit</h3>
  <dl title='dictionary BlobEventInit' class='idl'>
          <dt>Blob data</dt>
          <dd>
            A Blob object containing the data to deliver via this event.
          </dd>
        </dl>
</section>

<section id="availablesettings">
	<h3>Settings Dictionaries</h3>
	<dl title='dictionary AvailableSettings' class='idl'>
          <dt>CapabilityList MimeType</dt>
          <dd>
            A list of the MIME types that can be selected as encodings for recording.
          </dd>
          <dt>CapabilityRange imageWidth</dt>
          <dd>The maximum and minimum width, in pixels, for the capture of video or photo
          	images.</dd>
          	<dt>CapabilityRange imageHeight</dt>
          <dd>The maximum and minimum height, in pixels, for the capture of video or photo
          	images.</dd>
        </dl>
        
 <dl title='dictionary RecordingSettings' class='idl'>
          <dt>DOMString? MimeType</dt>
          <dd>
            Used to set the value of <code>mimeType</code>.
          </dd>
          <dt>unsigned long? imageWidth</dt>
          <dd>Used to set hte value of <code>imageWidth</code>.</dd>
          	<dt>unsigned long? imageHeight</dt>
          <dd>Used to set the value of <code>imageWidth</code>.</dd>
        </dl>
   
	</section>


   <section id="error-handling">
      <h2>Error Handling</h2>

      <section id="general-principles">
        <h3>General Principles</h3>

        <p>Errors are indicated in two ways: exceptions and objects passed to
        error callbacks. Both forms of error reporting <em title="must" class="rfc2119">must</em> provide an object
        of type <code>RecordingError</code>. An exception <em title="must" class="rfc2119">must</em> be thrown in the
        following cases:</p>

        <ul>
          <li>The type of any argument passed to a function did not match what
          was expected. An appropriate string from the
          <code>RecordingExceptionName</code> enum <em title="must" class="rfc2119">must</em> be used as the error
          name.</li>

          <li>A function call was made when the Recorder is in an
          invalid state, or a state in which that particular function is not
          allowed to be executed. In this case, the string
          <code>INVALID_STATE</code> <em title="must" class="rfc2119">must</em> be used as the error name.</li>
        </ul>

        <p>In all other cases, an error object <em title="must" class="rfc2119">must</em> be provided to the failure
        callback. The error name in the object provided <em title="must" class="rfc2119">must</em> be picked from
         the <code>RecordingErrorName</code>
        enums.  After raising the error, the UA <em title="must" class="rfc2119">must</em>
   	raise a  dataavailable event, containing any data that it has gathered,
   	and then a recordingdone event. The UA  <em title="may" class="rfc2119">may</em> set platform-specific
   	limits, such those for the minimum and maximum Blob size that it will support, or the number of 
   	Tracks it will record at once.  It <em title="must" class="rfc2119">must</em> signal a fatal
   	error if these limits are exceeded.  If a non-fatal error occurs during recording, the UA 
   	<em title="should" class="rfc2119">should</em> raise a recordingwarning event, with data indicating
   	the nature of the problem, and continue recording.</p>
 </section>   
     
<section id="recordingerror">
        <h3>RecordingError</h3>
        
        <dl title='interface RecordingError : Error' class='idl'>
        	<dt>readonly attribute RecordingErrorEnum  name</dt>
        	<dd>A string representing the type of the error. </dd>
        	<dt>readonly attribute DOMString? message</dt>
       <dd>A human readable description of the error. This string MAY vary between different user agents.</dd>
        	</dl>
        	
 
  <dl title='dictionary RecordingErrorInit' class='idl'>
          <dt>RecordingErrorEnum name</dt>
          <dd>
            Used to set the <code>name</code> attribute.
          </dd>
          <dt>DOMString? message</dt>
          <dd>Used to set the <code>message</code> attribute.</dd>
        </dl>
<section>
	<h4>RecordingErrorNameEnum</h4>
	<dl title="enum RecordingErrorNameEnum" class="idl">
		<dt>OUT_OF_MEMORY</dt>
		<dd>The UA has exhaused the available memory. User agents SHOULD provide as much additional information as possible in the <code>message</code> attribute.</dd>
	<dt>ILLEGAL_STREAM_MODIFICATION	</dt>
	<dd>A modification to the <code>stream</code> has occurred that makes it impossible to continue recording. An example would be the addition of a Track while recording is occurring. 
		User agents SHOULD provide as much additional information  as possible in the <code>message</code> attribute.</dd>
	<dt>"OTHER_RECORDING_ERROR"</dt>
	<dd>Used for an fatal error other than those listed above.  User agents SHOULD provide as much additional information as possible in the <code>message</code> attribute.</dd>
	
	</section>
</section> 
<section id="recordingexceptionenum">
	<h2>RecordingExceptionEnum</h2>
	<dl title="enum RecordingExcedptionEnum" class="idl">
		<dt>INVALID_STATE</dt>
		<dd>The function was called on a <code>MediaRecorder</code> that
          is an invalid state, or a state in which the function is not allowed
          to be executed.</dd>
		<dt>INVALID_MEDIASTREAM_TRACK_ID</dt>
		<dd>	The argument provided is not the ID of any <code>MediaStreamTrack</code> belonging to the <code>MediaRecorder</code>'s <code>stream</code>.</dd>
    <dt>UNSUPPORTED_OPTION</dt>
    <dd>The UA cannot provide the codec or recording option that has
          	been requested.</dd>
	</section> 
  
</section>  
 <section id="event-summary" class="informative">
   <h2>Event summary</h2>


    <p>The following additional events fire on <code><a class="idlType" href="#idl-def-MediaRecorder"><code>MediaRecorder</code></a></code>
    objects:</p>

    <table style="border-width:0; width:60%" border="1">
      <tbody><tr>
        <th>Event name</th>

        <th>Interface</th>

        <th>Fired when...</th>
      </tr>

      </tbody><tbody>
        <tr>
          <td><dfn id="event-mediarecorder-recording"><code>recording</code></dfn></td>

          <td><code>Event</code></td>

          <td>The UA has started recording data on the MediaStream.</td>
        </tr>

        <tr>
          <td><dfn id="event-mediarecorder-stoprecording"><code>stoprecording</code></dfn></td>

          <td><code>Event</code></td>

          <td>The UA has stopped recording data on the MediaStream.</td>
        </tr>
        
        <tr>
          <td><dfn id="event-mediarecorder-dataavailable"><code>dataavailable</code></dfn></td>

          <td><a href="#idl-def-BlobEvent"><code>BlobEvent</code></a></td>
          <td>The UA generates this even to return data to the application.  The 'data' attribute of this 
          	event contains a Blob of recorded data.</td>
        </tr>
        
         <tr>
          <td><dfn id="event-mediarecorder-photo"><code>photo</code></dfn></td>

          <td><a href="#idl-def-BlobEvent"><code>BlobEvent</code></a></td>

          <td>The UA uses this event to return a  photo to the application (as a Blob).  The 'data' attribute of this 
          	event contains a Blob of recorded snapshot data.</td>
        </tr>
        
        <tr>
          <td><dfn id="event-mediarecorder-pause"><code>pause</code></dfn></td>

          <td><code>Event</code></td>

          <td>The UA has paused recording data on the MediaStream.</td>
        </tr>
        
         <tr>
          <td><dfn id="event-mediarecorder-resume"><code>resume</code></dfn></td>

          <td><code>MediaStreamEvent</code></td>

          <td>The UA has resumed recording data on the MediaStream.</td>
        </tr>
        
         <tr>
          <td><dfn id="event-mediarecorder-mutetrack"><code>mutetrack</code></dfn></td>

          <td><a href="http://dev.w3.org/2011/webrtc/editor/getusermedia.html"><code>MediaStreamTrackEvent</code></a></td>

          <td>The MediaRecorder has muted recording on a Track.</td>
        </tr>
        
         <tr>
          <td><dfn id="event-mediarecorder-unmutetrack"><code>unmutetrack</code></dfn></td>

          <td><a href="http://dev.w3.org/2011/webrtc/editor/getusermedia.html"><code>MediaStreamTrackEvent</code></a></td>

          <td>The MediaRecorder has unmuted recording on a Track.</td>
        </tr>
  

        

        <tr>
          <td><dfn id="event-mediarecorder-recordingerror"><code>recordingerror</code></dfn></td>

          <td><a href="#idl-def-RecordingError"><code>RecordingError</code></a></td>

          <td>A fatal error has occurred and the UA has stopped recording. More  detailed error information
          	is available in the 'message' attribute. </td>
        </tr>
        
          <tr>
          <td><dfn id="event-mediarecorder-recordingwarning"><code>recordingwarning</code></dfn></td>

          <td><code>CustomEvent</code></td>

          <td>A problem has occurred, but the UA has not stopped recording. More detailed information
          	is available in the 'message' attribute. [Not clear if we need this event.]</td>
        </tr>

      </tbody>
    </table>

  </section>

  	
 <section class="appendix" id="openissues"><!--OddPage--><h2><span class="secno">A. </span>Open Issues</h2>
 	<ol>
 		<li>Do we need an MTI
        	format?</li>
        	<li>Do we need a "setSyncPoint()" operator and a "syncpoint" signal, 
        		so that the client can tell the recorder to insert a point at 
        		which a recording can be broken up (typically a new I-frame)? </li>
        		<li>Do we need to ask the user's permission before we record?</li>
 		</ol>
</section>


  </body></html>
